package main

import (
	"path"
	"strings"
	"testing"
	"time"

	"github.com/gotk3/gotk3/gtk"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"pgregory.net/rapid"
)

func TestDisplayItems(t *testing.T) {
	initTreeStore(t)
	core = &Core{
		Items: []Item{
			{
				Path: "seventeen",
				Left: Content{File, Created, "modified on 2021-02-06 at 18:42:07  size 0         rw-r--r--",
					time.Date(2021, 2, 6, 18, 42, 7, 0, time.Local), 0},
				Right:  Content{Absent, Unchanged, "", time.Time{}, 0},
				Action: LeftToRight,
			},
			{
				Path: "six/eight",
				Left: Content{File, Unchanged, "modified on 2021-02-06 at 18:42:07  size 1146      rw-r--r--",
					time.Date(2021, 2, 6, 18, 42, 7, 0, time.Local), 1146},
				Right: Content{File, Modified, "modified on 2021-02-06 at 18:42:08  size 1147000   rw-rw-r--",
					time.Date(2021, 2, 6, 18, 42, 8, 0, time.Local), 1147000},
				Action: RightToLeft,
			},
		},
	}
	displayItems()

	assertEqual(t, probeRow(t, treestore, "1", colName, colLeft, colAction, colRight),
		[]interface{}{"six/eight", "", "‚Üê", "changed"})
}

func initTreeStore(t *testing.T) {
	t.Helper()
	builder, err := gtk.BuilderNewFromString(ui)
	require.NoError(t, err)
	treestore = mustGetObject(builder, "treestore").(*gtk.TreeStore)
}

func probeRow(t *testing.T, store *gtk.TreeStore, path string, cols ...int) []interface{} {
	t.Helper()
	p, err := gtk.TreePathNewFromString(path)
	require.NoError(t, err)
	iter, err := store.GetIter(p)
	require.NoError(t, err)

	row := make([]interface{}, len(cols))
	for i, col := range cols {
		v, err := store.GetValue(iter, col)
		require.NoError(t, err)
		row[i], err = v.GetString()
		require.NoError(t, err)
	}
	return row
}

func genItems(t *rapid.T) []Item {
	items := make([]Item, rapid.IntRange(0, 99).Draw(t, "len").(int))
	seen := make(map[string]bool)
	for i := 0; i < len(items); i++ {
		// For these tests, we don't care strongly about fields other than Path.
		// Fill them with something, just in case.
		items[i] = Item{
			Left:   Content{Type: File, Status: Modified},
			Right:  Content{Type: File, Status: Modified},
			Action: Skip,
		}

		if rapid.IntRange(0, 99).Draw(t, "empty").(int) == 0 { // Path may be empty ("entire replica").
			continue
		}

		// To generate a new Path, take the previous Path (if any),
		// chop off some of its final segments, and append some new segments.
		if i > 0 {
			items[i].Path = items[i-1].Path
			if rapid.IntRange(0, 99).Draw(t, "choppy").(int) == 0 { // Occasionally
				// we may have e.g. "foo/bar" (dir props changed) and "foo/bar/baz" (modified).
				// To simulate this, don't chop off "bar", just append "baz".
				items[i-1].Left = Content{Type: Directory, Status: PropsChanged}
				items[i-1].Right = Content{Type: Directory, Status: PropsChanged}
			} else {
				maxchop := strings.Count(items[i].Path, "/") + 1
				for nchop := rapid.IntRange(1, maxchop).Draw(t, "nchop").(int); nchop > 0; nchop-- {
					items[i].Path = path.Dir(items[i].Path)
				}
				if items[i].Path == "." { // returned by path.Dir
					items[i].Path = ""
				}
			}
		}
		for ngrow := rapid.IntRange(1, 5).Draw(t, "ngrow").(int); ngrow > 0; ngrow-- {
			segment := rapid.StringMatching(`[a-z]{1,5}`).Draw(t, "segment").(string)
			items[i].Path = path.Join(items[i].Path, segment)
		}

		// Avoid duplicate paths.
		for seen[items[i].Path] {
			items[i].Path += rapid.StringMatching(`[0-9]`).Draw(t, "uniq").(string)
		}
		seen[items[i].Path] = true
	}
	return items
}

func TestGenItems(t *testing.T) { // FIXME
	for _, item := range rapid.Custom(genItems).Example().([]Item) {
		t.Log(item.Path)
	}
}

// TestDisplayItemsContiguous checks the following property:
// Leaf nodes generated by displayItems correspond 1-to-1 to the input items in the same order.
// In other words, displayItems only extracts contiguous groups from the items that it is given,
// never rearranges them.
func TestDisplayItemsContiguous(t *testing.T) {
	initTreeStore(t)
	rapid.Check(t, func(t *rapid.T) {
		core.Items = rapid.Custom(genItems).Draw(t, "items").([]Item)
		treestore.Clear()
		displayItems()
		cur := 0
		forEachNode(func(iter *gtk.TreeIter) {
			idx := MustGetColumn(treestore, iter, colIdx).(int)
			if treestore.IterHasChild(iter) { // not a leaf node
				assert.Equal(t, -1, idx)
				return
			}
			assert.Less(t, idx, len(core.Items))
			assert.Equal(t, cur, idx)
			cur++
		})
	})
}

// TestDisplayItemsNamesPaths checks the following property:
// The path of every node generated by displayItems equals a join of its name
// and the names of its ancestors (in reverse order).
func TestDisplayItemsNamesPaths(t *testing.T) {
	initTreeStore(t)
	rapid.Check(t, func(t *rapid.T) {
		core.Items = rapid.Custom(genItems).Draw(t, "items").([]Item)
		treestore.Clear()
		displayItems()
		forEachNode(func(iter *gtk.TreeIter) {
			var names []string
			for {
				name := MustGetColumn(treestore, iter, colName).(string)
				names = append([]string{name}, names...)
				parent, _ := treestore.GetIterFirst() // must be a valid TreeIter for the following call
				if !treestore.IterParent(parent, iter) {
					break
				}
				iter = parent
			}
			assert.Equal(t, path.Join(names...), MustGetColumn(treestore, iter, colPath).(string))
		})
	})
}

// TestDisplayItemsAncestors checks the following property:
// For any node1 and node2 (with path1 and path2) generated by displayItems,
// node1 is an ancestor of node2 iff path1 is an ancestor of path2 and node1 has any children.
// In other words, displayItems generates a parent node only when it can contain all the relevant items.
func TestDisplayItemsAncestors(t *testing.T) {
	initTreeStore(t)
	rapid.Check(t, func(t *rapid.T) {
		core.Items = rapid.Custom(genItems).Draw(t, "items").([]Item)
		treestore.Clear()
		displayItems()
		forEachNode(func(iter1 *gtk.TreeIter) {
			path1 := MustGetColumn(treestore, iter1, colPath).(string)
			treepath1, err := treestore.GetPath(iter1)
			require.NoError(t, err)
			forEachNode(func(iter2 *gtk.TreeIter) {
				path2 := MustGetColumn(treestore, iter2, colPath).(string)
				treepath2, err := treestore.GetPath(iter2)
				require.NoError(t, err)
				assert.Equal(t,
					strings.HasPrefix(path2, path1+"/") && treestore.IterHasChild(iter1),
					treepath1.IsAncestor(treepath2),
				)
			})
		})
	})
}

// TestDisplayItemsMultipleChildren checks the following property:
// displayItems generates parent nodes only for multiple children
// (because if there's only one child, it can be subsumed into the parent).
func TestDisplayItemsMultipleChildren(t *testing.T) {
	initTreeStore(t)
	rapid.Check(t, func(t *rapid.T) {
		core.Items = rapid.Custom(genItems).Draw(t, "items").([]Item)
		treestore.Clear()
		displayItems()
		forEachNode(func(iter *gtk.TreeIter) {
			assert.NotEqual(t, 1, treestore.IterNChildren(iter))
		})
	})
}

func forEachNode(f func(*gtk.TreeIter)) {
	treestore.ForEach(gtk.TreeModelForeachFunc(
		func(_ *gtk.TreeModel, _ *gtk.TreePath, iter *gtk.TreeIter, _ ...interface{}) bool {
			f(iter)
			return false // means "continue ForEach"
		},
	))
}
